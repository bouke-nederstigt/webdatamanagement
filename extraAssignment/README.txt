1. Counting Triangles in Giraph

	a. Overview of Implementation

       The first implementation makes use of Giraph's message passing paradigm to send messages along a triangle's edges in order to discover it. The TriangleCounterInGiraph class extends Giraph's BasicComputation class to carry out a 4-step computation on the graph expressed with LongLongNullTextInputFormat. The final value of each vertex represents the number of triangles in which that vertex is the one with the smallest identifier and is written to the output with IdWithValueTextOutputFormat. Adding these values up gives the final number of triangles in the graph.

	b. Algorithm Description 

	In the first superstep, all vertices send their identifiers in messages to their neighbors which have a greater identifier than themselves. Thus, messages travel on edges of type XY (smallest vertex in triangle to middle vertex). Next, all vertices forward the messages they received to their neighbors which have an even greater identifier. Messages, now travel on edges of type YZ (middle vertex to greatest vertex in the triangle). The last edge is discovered when all vertices forward the messages they received to all their neighbors. When each vertex counts how many messages received in the previous step contain their identifier, they obtain the number of triangle in which they have the smallest identifier.

	The pseudocode of the implementation is given below:

        //Step 1
            foreach neighbor in Neighbors
                if neighbor > self
                    send self.id to neighbor

		//Step 2
			foreach message in ReceivedMessages
				foreach neighbor in Neighbors
					if neighbor > self
						send message to neighbor
						
		//Step 3
			foreach message in ReceivedMessages
				foreach neighbor in Neighbors
						send message to neighbor
						
		//Step 4
			count = 0
			foreach message in ReceivedMessages
				if message == self.id
					count++
			self.value = count
         
2. Counting Triangles Via 3-way Join in MapReduce

	a. Overview of Implementation

	The second implementation attempts a 3-way join between 3 copies of the edge relation. TriangleCounterInHadoop uses the Mapper-Reducer combination to first send edges to their appropriate reducers in the theoretical "matrix" and then compute at each reducer how many triangles are formed. By default, the number of buckets (b) used is 2, resulting in 2^3=8 reducers needed to count triangles. This value can be overridden via a third command-line option (after the basic input and output path parameters). As in the previous case, the output is a set of pairs (reducer_number reducer_count). Summing up all the reducers' counts gives the final number of triangles.

	b. Algorithm Description
	
	The algorithm follows that described in the "Optimizing Multi-Way Join on MapReduce" lecture given by dr. Jacek Sroka. The mapper reads the input and creates only edges (a, b) with a < b. It computes h(a) and h(b) and sends edge (a,b) to reducers of the form 
	1. (h(a), h(b), *), as an XY edge (from smallest vertex in triangle to the middle vertex)
	2. (*, h(a), h(b)), as an YZ edge (from middle vertex to the greatest vertex in the triangle)
	3. (h(a), *, h(b)), as an XZ edge (from the smallest to the greatest vertex in the triangle)
	The reducers each receive edges of the 3 different types. For each edge of type XY, they search for a compatible YZ edge and, if the closing XZ edge is also found, they count that triangle once.
	
	The pseudocode of this implementation is given below:
	
		//Mapper
			set b to number of buckets
            foreach edge (v1, v2) in Input
                if v1 < v2
                    h1 = modulo(v1, b)
                    h2 = modulo(v2, b)
                    foreach i < b
                        send (v1, v2, XY) to reducer h1*b^2 + h2*b + i
                        send (v1, v2, YZ) to reducer i*b^2 + h1*b + h2
                        send (v1, v2, XZ) to reducer h1*b^2 + i*b + h2

   		//Reducer
            count = 0
            foreach (v1, v2, XY) in Received
                foreach (v2, v3, YZ) in Received
                   if Received contains (v1, v3, XZ)
                       count++
			self.output = count 

3. Testing

	Automated tests were carried out to compare the results of the two implementations with the result of the trivial algorithm computed on the same input. The pseudocode of this algorithm is given below:
	
	foreach (v1, v2) in Edges
        foreach (v2, v3) in Edges
           if Edges contains (v1, v3)
                       count++
	
	The graph for each test is generated by randomly adding edges to a set of vertices until reaching a specific density of edges, between 0 (no edges) and 1 (complete graph). The tests are automatic and can be run any time using the TriangleCountingTester. We carried out 15 tests, involving graphs with 10, 20, 30, 50, and 100 vertices and densities of 0.4, 0.6, and 0.8 (these can be found in the project folder). The three resulting values were identical in all cases.
	
4. Analysis	

	It is worth mentioning that the cost in communication or runtime was not evaluated in the tests. 
	
	Optimizations on the code are possible for both implementations. For instance, the Giraph version would benefit from a preliminary renaming phase of the nodes. Since messages are passed to neighbors with a greater identifier, it would be optimal to have the vertices with fewer neighbors (smaller degree) have smaller identifiers. Likewise, the multi-way join could suffer the modifications expressed in the book "Mining of Massive Datasets" by Anand Rajaraman and Jeffrey Ullman (available at http://infolab.stanford.edu/~ullman/mmds/book.pdf). The authors suggest "renaming" each vertex to the pair (h(v), v) and reordering the vertices. Thus, the number of reducers and, consequently, the communication cost, is cut down to a third, since only reducers (i,j,k), with i, j, k in ascending order, remain.
	
	Moreover, the Hadoop jobs were run using the default configuration, in a pseudo-distributed manner. Greater speed and computation efficiency can be obtained by tailoring the runtime environment to the specific problem.
